// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package pg

import (
	"context"
	"database/sql"
)

const createSet = `-- name: CreateSet :one
INSERT INTO sets (set_uid)
VALUES ($1)
RETURNING id, set_uid
`

func (q *Queries) CreateSet(ctx context.Context, setUid []byte) (Set, error) {
	row := q.db.QueryRowContext(ctx, createSet, setUid)
	var i Set
	err := row.Scan(&i.ID, &i.SetUid)
	return i, err
}

const createSetData = `-- name: CreateSetData :exec
INSERT INTO sets_datas(data, set_uid)
VALUES ($1, $2)
`

type CreateSetDataParams struct {
	Data   sql.NullInt64
	SetUid []byte
}

func (q *Queries) CreateSetData(ctx context.Context, arg CreateSetDataParams) error {
	_, err := q.db.ExecContext(ctx, createSetData, arg.Data, arg.SetUid)
	return err
}

const getIntersectingSet = `-- name: GetIntersectingSet :one
SELECT id, set_uid, intersectingset_uid FROM intersecting_sets
WHERE set_uid = $1
`

func (q *Queries) GetIntersectingSet(ctx context.Context, setUid []byte) (IntersectingSet, error) {
	row := q.db.QueryRowContext(ctx, getIntersectingSet, setUid)
	var i IntersectingSet
	err := row.Scan(&i.ID, &i.SetUid, &i.IntersectingsetUid)
	return i, err
}

const getSetDatas = `-- name: GetSetDatas :many
SELECT id, data, set_uid 
FROM sets_datas
WHERE sets_datas.set_uid = $1
`

func (q *Queries) GetSetDatas(ctx context.Context, setUid []byte) ([]SetsData, error) {
	rows, err := q.db.QueryContext(ctx, getSetDatas, setUid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SetsData
	for rows.Next() {
		var i SetsData
		if err := rows.Scan(&i.ID, &i.Data, &i.SetUid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIntersectingSets = `-- name: ListIntersectingSets :many
SELECT id, set_uid, intersectingset_uid FROM intersecting_sets
ORDER BY set_uid
`

func (q *Queries) ListIntersectingSets(ctx context.Context) ([]IntersectingSet, error) {
	rows, err := q.db.QueryContext(ctx, listIntersectingSets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IntersectingSet
	for rows.Next() {
		var i IntersectingSet
		if err := rows.Scan(&i.ID, &i.SetUid, &i.IntersectingsetUid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSetsDatas = `-- name: ListSetsDatas :many
SELECT id, data, set_uid
FROM sets_datas
ORDER BY set_uid
`

func (q *Queries) ListSetsDatas(ctx context.Context) ([]SetsData, error) {
	rows, err := q.db.QueryContext(ctx, listSetsDatas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SetsData
	for rows.Next() {
		var i SetsData
		if err := rows.Scan(&i.ID, &i.Data, &i.SetUid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setIntersectingSet = `-- name: SetIntersectingSet :exec
INSERT INTO intersecting_sets(set_uid, intersectingset_uid)
VALUES ($1, $2)
`

type SetIntersectingSetParams struct {
	SetUid             []byte
	IntersectingsetUid []byte
}

func (q *Queries) SetIntersectingSet(ctx context.Context, arg SetIntersectingSetParams) error {
	_, err := q.db.ExecContext(ctx, setIntersectingSet, arg.SetUid, arg.IntersectingsetUid)
	return err
}
